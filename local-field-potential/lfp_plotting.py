# -*- coding: utf-8 -*-
"""
Created on Fri Dec 13 12:55:04 2024

@author: ssenapat

PLOTTING ONLY FOR MUSIC
"""

def load_trigger():
    '''
    Returns
    -------
    sorted_trigger_loc : TYPE
        Generates trigger information for music pieces

    '''
    # read the saved trigger channel info
    # file = '/home/ssenapat/groups/PrimNeu/Final_exps_spikes/LFP/Elfie/p1/p1_15/trigger_onset_for_py.npy'
    file = Path('G:/Final_exps_spikes/LFP/Elfie/p1/p1_15/trigger_onset_for_py.npy')
    triggers = pd.DataFrame(np.load(file))
    
    return triggers



def load_onset_response(file):
    '''
    Returns
    -------
    sorted_trigger_loc : TYPE
        Generates trigger information for music pieces

    '''
    
    # read all saved onset response per channel info - generated by lfp_onset_response.py
    onsets = pd.read_csv(file, header=None)
    
    return onsets


def identify_channel(filepath):
    
    folder = str(filepath)     

    folder_name_loc = re.search(r"channel[0-9]+", folder)
    ind = folder_name_loc.span()
    channelID = folder[ind[0]+7:ind[1]]        # get rid of the 'LFP' at the start of the channel ID name
    
    return int(channelID)



def plot_tones_per_channel(chan_matrix, channel_num, trigger, savehere):
    
    ### USE NUMPY ARRAY SPLIT() HERE
    # averaging across each datapoint in this matrix (9 plots per channel, since averaging to be done for every 10 consecutive tones)
    avg_every_tone = np.zeros(3750)
    
    for ii in range(9):
        mean_across_tone = np.mean(chan_matrix[ii:ii+10], axis=0)
        avg_every_tone = np.vstack([avg_every_tone, mean_across_tone])
        ii = ii+10      # each stimulus has 10 trials
    
    avg_every_tone = np.delete(avg_every_tone, [0], axis=0) # remove 1st row, which is not crucial
    
    avg_every_tone_df = pd.DataFrame(avg_every_tone)        
    
    # #%matplotlib qt
    
    
    x = range(3750)
    #fig, axs = plt.subplots(1, 2, gridspec_kw={'width_ratios': [1, 3]})
    fig = plt.plot()
    # fig.tight_layout()
    fig.set_figheight(15)
    fig.set_figwidth(20)
    
    # plot all avg amplitudes per channel
    for ii in range(9):
        (ii*500 + avg_every_tone_df.T.iloc[:,ii]).plot()
    
    
    
    # x_ticks = np.arange(0, 1200, 250)
    # x_ticklabels = ([-100, 0, 100, 200, 300])
    # axs[0].set_xticks(x_ticks)
    # axs[0].set_xticklabels(x_ticklabels)
    
    # y_ticks = np.arange(0, 4000, 100)
    # # y_ticklabels = (trigger_freq)
    # axs[0].set_yticks(y_ticks)
    # # axs[0].set_yticklabels(y_ticklabels)
    
    # axs[0].set_ylim(-75, 4000)
    
    axs[0].set_xlabel('Time (in ms)')
    axs[0].set_ylabel('Frequency (in Hz)')
    # axs[0].set_title('Average amplitude per frequency')
    
    
    # # heatmap
    # # fig = plt.subplots(figsize=(5, 10), dpi=80)
    # x_ticks = np.arange(0, 1200, 250)
    # x_ticklabels = ([-100, 0, 100, 200, 300])
    
    # # axs[1] = sns.heatmap(np.flip(avg_every_tone, 0), yticklabels = np.flip(trigger_freq, 0), cmap="crest", vmax=200, vmin=-200)     # reorder the array for plotting purpose
    # axs[1] = sns.heatmap(np.flip(avg_every_tone, 0), cmap="crest", vmax=200, vmin=-200)     # reorder the array for plotting purpose
    # # axs[1].set_xticks(x_ticks)
    # # axs[1].set_xticklabels(x_ticklabels, rotation=0)
    # axs[1].axvline(x = 251, color = 'w', linestyle='dashed')
    # axs[1].set_xlabel('Time (in ms)')
    # # axs[1].set_title('Average amplitude per frequency - heatmap')
    
    
    save_loc = str(savehere) + '/tones_per_channel'
    if not os.path.exists(save_loc):     # if the required folder does not exist, create one
        os.mkdir(save_loc)
    
    plt.savefig(str(save_loc) + '/channel' + str(channel_num) + '.png')
    plt.close()
    

'''
def plot_channels_per_tone(allchans, trial, freq, trigger_num, savehere, depths):
    
    save_loc = str(savehere) + '/channels_per_tone'
    if not os.path.exists(save_loc):     # if the required folder does not exist, create one
        os.mkdir(save_loc)
    # arraged as: chan1 10 trials, chan2 10 trials, and so on ...

    chan_matrix = np.zeros(1000)
    
    for chan in range(0,len(allchans.T)):
        channel = allchans[:,chan]
        
        for ii in range(len(trial)):
            # relevant_points = channel[trigger[1].iloc[ii]-250:trigger[1].iloc[ii]+750]  # we look at 100 millisec before and 300 millisec after trigger onset
            relevant_points = channel[trial[ii]-250:trial[ii]+750]  # we look at 100 millisec before and 300 millisec after trigger onset
            chan_matrix = np.vstack([chan_matrix, relevant_points])

            
    chan_matrix = np.delete(chan_matrix, [0], axis=0) # remove 1st row, which is not crucial
    
    avg_every_channel = np.zeros(1000)
    
    for ii in range(384):
        mean_across_channel = np.mean(chan_matrix[ii:ii+10], axis=0)
        avg_every_channel = np.vstack([avg_every_channel, mean_across_channel])
        ii = ii+10
        
    avg_every_channel = np.delete(avg_every_channel, [0], axis=0) # remove 1st row, which is not crucial
    
    avg_every_channel_df = pd.DataFrame(avg_every_channel, index=depths)
    
    # #%matplotlib qt
    
    # heatmap
    fig, axs = plt.subplots(figsize=(15, 10))
    
    # axs = sns.heatmap(np.flip(avg_every_channel, 0), yticklabels = np.flip([range(384)], 0), cmap="crest", vmax=200, vmin=-200)     # reorder the array for plotting purpose
    sns.heatmap(avg_every_channel_df, cmap="crest", vmax=200, vmin=-200)
    
    x_ticks = np.arange(0, 1200, 250)
    x_ticklabels = ([-100, 0, 100, 200, 300])
    axs.set_xticks(x_ticks)
    axs.set_xticklabels(x_ticklabels, rotation=0)
    axs.axvline(x = 251, color = 'w', linestyle='dashed')
    axs.set_xlabel('Time (in ms)')
    axs.set_title('Trigger frequency:' + str(freq) + ' Hz' )
    
    # # y_ticks = np.arange(0, 384, 20)
    # y_ticklabels = (depths)
    # # axs.set_yticks(y_ticks)
    # axs.set_yticklabels(y_ticklabels)
    axs.set_ylabel('Depth')
    
    plt.savefig(str(save_loc) + '/trigger' + str(freq) + 'Hz_hm.png')
    plt.close()
    


    # waveform
    fig2, axs2 = plt.subplots(figsize=(5, 15))
    x = range(1000)
    
    # plot all avg amplitudes per channel
    for ii in range(5, 384, 9):
        axs2.plot(x, avg_every_channel[ii] + ii*10, 'k')
    
    axs2.axvline(x = 251, color = 'r', linestyle='dashed')
    
    x_ticks = np.arange(0, 1200, 250)
    axs2.set_xticks(x_ticks)
    x_ticklabels = ([-100, 0, 100, 200, 300])
    axs2.set_xticklabels(x_ticklabels)
    
    y_ticks = np.arange(0, 3840, 90)
    axs2.set_yticks(y_ticks)
    y_ticklabels = depths.iloc[5::9]
    axs2.set_yticklabels(y_ticklabels)
    
    # axs2.set_ylim(-75, 4000)
    
    axs2.set_xlabel('Time (in ms)')
    axs2.set_ylabel('Depth')
    
    axs2.set_title('Trigger frequency:' + str(freq) + ' Hz (waveforms)' )
    plt.savefig(str(save_loc) + '/trigger' + str(freq) + 'Hz_wf.png')
    plt.close()
    
'''

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
from pathlib import Path
import re



trigger = load_trigger()


directory = Path('G:/Final_exps_spikes/LFP/Elfie/p1/p1_15/onset_responses/')

for chan in os.listdir(directory):
    filepath = str(directory) + '/' + chan
    onset_mat = load_onset_response(filepath)
    channel_num = identify_channel(filepath)       # identify current channel based on filepath
    
    # for each channel
    savehere = Path('G:/Final_exps_spikes/LFP/Elfie/p1/p1_15/plots/')
    if not os.path.exists(savehere):     # if the required folder does not exist, create one
        os.mkdir(savehere)
    
    # plot every tone per channel
    plot_tones_per_channel(onset_mat, channel_num, trigger, savehere)
    
    

